---
title: "Data Classes"
author: "Andrew Jaffe"
date: "January 5, 2016"
output:
  beamer_presentation: default
  ioslides_presentation:
    css: ../../styles.css
---

## Functions - Intro

* R revolves around functions: denoted by `[function name]()`
* Every function takes an input, defined by arguments, often provided by the user
* Many functions have default settings for these arguments
* `example([function name])` shows you how it is used

## R Help
* If you know the name of a function, `?[function name]` or `help([function name])` will pop up the help menu

```{r assign_help}
## ?str
## help("str")
```

## Functions - Intro

For example, `length` is a function we briefly covered last module. You can try typing `?length` in the console and reading the help file.

You can also see examples of running a function using `example()` [which is another function!]

## Data Classes:

* One dimensional classes ('vectors'):
    * Character: strings or individual characters, quoted
    * Numeric: any real number(s)
    * Integer: any integer(s)/whole numbers
    * Factor: categorical/qualitative variables
    * Logical: variables composed of TRUE or FALSE

## Data Classes:

* Two dimensional classes:
    * `data.frame`: traditional 'Excel' spreadsheets
        * Each column can have a different class, from above
    * Matrix: two-dimensional data, composed of rows and columns. Unlike data frames, the entire matrix is composed of one R class, e.g. all numeric or all characters.

## Character and numeric

We have already covered `character` and `numeric`

```{r numChar}
class(c("Andrew", "Jaffe"))
class(c(1, 4, 7))
```

Recall that `c()` and `class()` are both functions!

## Integer

`Integer` is a special subset of `numeric` that contains only whole numbers

A sequence of numbers is an example of the integer class

```{r seq}
x = seq(from = 1, to = 5) # seq() is a function
x
class(x)
```

## Integer

The colon `:` is a shortcut for making sequences of numbers

It makes consecutive integer sequence from `[num1]` to `[num2]` by 1


```{r seqShort}
1:5
```


## Logical

`logical` is a class that only has two possible elements: `TRUE` and `FALSE`

```{r logical1}
x = c(TRUE, FALSE, TRUE, TRUE, FALSE)
class(x)
```

`sum()` and `mean()` work on `logical` vectors - they return the total and proportion of `TRUE` elements, respectively.

## Logical

Note that `logical` elements are NOT in quotes. 
```{r logical2}
z = c("TRUE", "FALSE", "TRUE", "FALSE")
class(z)
```


## Factor

`factor` are special `character` vectors where the elements have pre-defined groups or 'levels'. You can think of these as qualitative or categorical variables:

```{r factor1}
x = factor(c("boy", "girl", "girl", "boy", "girl"))
x 
class(x)
```

Note that levels are, by default, alphabetical or alphanumerical order.


## Factors

Factors are used to represent categorical data, and can also be used for ordinal data (ie categories have an intrinsic ordering)

Note that R reads in character strings as factors by default in functions like `read.table()`

'The function factor is used to encode a vector as a factor (the terms 'category' and 'enumerated type' are also used for factors). If argument ordered is TRUE, the factor levels are assumed to be ordered.'

```
factor(x = character(), levels, labels = levels,
       exclude = NA, ordered = is.ordered(x))
```

## Factors

Suppose we have a vector of case-control status

```{r factor2}
cc = factor(c("case","case","case",
        "control","control","control"))
cc
levels(cc) = c("control","case")
cc
```

## Factors

Note that the levels are alphabetically ordered by default. We can also specify the levels within the factor call

```{r factor_cc_again}
factor(c("case","case","case","control",
          "control","control"), 
        levels =c("control","case") )
factor(c("case","case","case","control",
            "control","control"), 
        levels =c("control","case"), ordered=TRUE)
```

## Factors

Factors can be converted to `numeric` or `character` very easily

```{r factor3}
x = factor(c("case","case","case","control",
      "control","control"),
        levels =c("control","case") )
as.character(x)
as.numeric(x)
```


## Creating categorical variables

the `rep()` ["repeat"] function is useful for creating new variables 

```{r rep1}
bg = rep(c("boy","girl"),each=50)
head(bg)
bg2 = rep(c("boy","girl"),times=50)
head(bg2)
length(bg)==length(bg2)
```

## Creating categorical variables

One frequently-used tool is creating categorical variables out of continuous variables, like generating quantiles of a specific continuously measured variable. 

A general function for creating new variables based on existing variables is the `ifelse()` function, which "returns a value with the same shape as test which is filled with elements selected from either yes or no depending on whether the element of test is `TRUE` or `FALSE`."

```
ifelse(test, yes, no)

# test: an object which can be coerced
    to logical mode.
# yes: return values for true elements of test.
# no: return values for false elements of test.
```

## Charm City Circulator data

Please download the Charm City Circulator data:

http://www.aejaffe.com/winterR_2016/data/Charm_City_Circulator_Ridership.csv

```{r}
circ = read.csv("http://www.aejaffe.com/winterR_2016/data/Charm_City_Circulator_Ridership.csv", 
            header=TRUE,as.is=TRUE)
```

## Creating categorical variables

For example, we can create a new variable that records whether daily ridership on the Circulator was above 10,000.

```{r ifelse1}

hi_rider = ifelse(circ$daily > 10000, 1, 0)
head(hi_rider)
table(hi_rider)
```

## Creating categorical variables

You can also nest `ifelse()` within itself to create 3 levels of a variable.

```{r ifelse2}
riderLevels = ifelse(circ$daily < 10000, "low", 
                  ifelse(circ$daily > 20000,
                  "high", "med"))
head(riderLevels)
table(riderLevels)
```

## Creating categorical variables

However, it's much easier to use `cut()` to create categorical variables from continuous variables. 

'cut divides the range of x into intervals and codes the values in x according to which interval they fall. The leftmost interval corresponds to level one, the next leftmost to level two and so on.'

```
cut(x, breaks, labels = NULL, include.lowest = FALSE, 
  right = TRUE, dig.lab = 3,
  ordered_result = FALSE, ...)
```

## Creating categorical variables

`x`: a numeric vector which is to be converted to a factor by cutting.

`breaks`: either a numeric vector of two or more unique cut points or a single number (greater than or equal to 2) giving the number of intervals into which x is to be cut.

`labels`: labels for the levels of the resulting category. By default, labels are constructed using "(a,b]" interval notation. If `labels = FALSE`, simple integer codes are returned instead of a factor.


## Cut

Now that we know more about factors, `cut()` will make more sense:

```{r cut1}
x = 1:100
cx = cut(x, breaks=c(0,10,25,50,100))
head(cx)  
table(cx)
```


We can also leave off the labels

```{r cut2}
cx = cut(x, breaks=c(0,10,25,50,100), labels=FALSE)
head(cx)  
table(cx)
```

Note that you have to specify the endpoints of the data, otherwise some of the categories will not be created

```{r cut3}
cx = cut(x, breaks=c(10,25,50), labels=FALSE)
head(cx)  
table(cx)
table(cx,useNA="ifany")
```



## Vector functions

Useful functions for exploring vectors (and other data types):

* `length()` 
* `head()` and `tail()`
* `table()`
* `subset()` and brackets (`[ ]`)
* `unique()` 
* `sum()`, `mean()`,`median()`, `min()`, `max()`

## Head and Tail

* `head()` shows the first 6 (default) elements of an R object
* `tail()` shows the last 6 (default) elements of an R object
* `str()` shows the structure of an R object

## Head and Tail
 
```{r head}
z = 1:100 # recall a sequence from 1 to 100
head(z)
tail(z)
str(z)
```

These functions show a brief snapshot of the data which is useful for exploratory data analysis.

## Table {.smaller}

`table()` is the basic tabulation function, which is often more useful for `character` and `factor` vectors

From the manual: "table uses the cross-classifying factors to build a contingency table of the counts at each combination of factor level"

```{r tab}
x = c("boy", "girl", "girl", "boy", "girl")
table(x)
y = c(1, 2, 1, 2, 1)
table(x,y)
```

## Data Subsetting

Brackets are used to select/subset/extract data in R

```{r subset1}
x1 = 10:20
x1
length(x1)
```

## Data Subsetting

```{r subset2}
x1[1] # selecting first element
x1[3:4] # selecting third and fourth elements
x1[c(1, 5, 7)] # first, fifth, and seventh elements
```

#### **This is probably the most powerful and useful function in R. If you master this, you can literally do anything with R. Everything in the 'data analysis pipeline' revolves around subsetting (as you will soon see)**

## Matrices

```{r matrix}
n = 1:9 # sequence from first number to second number incrementing by 1
n
mat = matrix(n, nrow = 3)
mat
```

## Matrix (and Data frame) Functions

These are in addition to the previous useful vector functions:

* `nrow()` displays the number of rows of a matrix or data frame
* `ncol()` displays the number of columns 
* `dim()` displays a vector of length 2: # rows, # columns
* `colnames()` displays the column names (if any) and `rownames()` displays the row names (if any)

## Data Selection

Matrices have two "slots" you can use to select data, which represent rows and columns, that are separated by a comma, so the syntax is `matrix[row,column]`.

```{r subset3}
mat[1, 1] # individual entry: row 1, column 1
mat[1, ] # first row
mat[, 1] # first columns
```

## Data Selection

Note that the class of the returned object is no longer a matrix

```{r subset4}
class(mat[1, ])
class(mat[, 1])
```

## Data Frames

The `data.frame` is the other two dimensional variable class. 

Again, data frames are like matrices, but each column is a vector that can have its own class. So some columns might be `character` and others might be `numeric`, while others maybe a `factor`.

We can look at some of the example data frames that come with R.

## Data Frames {.smaller}

```{r df1}
data(iris) ## just use some data in R already
names(iris) ## get the column names
str(iris) # easy snapshot of data, like `describe` in Stata
head(iris, 3) # get top 3 rows
```

## Data Selection

Data frames have special ways to select data, specifically by a `$` and the column name.


```{r df2}
head(iris$Petal.Length)
class(iris$Petal.Width)
```

## Data Selection

You can also subset data frames like matrices, using row and column indices, but using column names is generally safer and more reproducible.

```{r subset6}
head(iris[, 2])
```

You can also use the bracket notation, but specify the name(s) in quotes if you want more than 1 column. This allows you to subset rows and columns at the same time
```{r subset7}
iris[1:3, c("Sepal.Width", "Species")]
```

## Data Frames

You can make your own data frames from "scratch" too, either from a matrix or using the `data.frame` function:

```{r df3}
x = c("Andrew", "Leonardo", "Shaun")
y = 1:3
df = data.frame(name = x, id = y)
df
```

## Data Frames {.smaller}

You can add variables to a `data.frame` using `$` as well:

```{r dfAdd}
iris2 = iris # copy `iris` to a new df
iris2$Index = 1:nrow(iris2)
head(iris2)
names(iris2)
```

## Data Classes: Extended

Extensions of "normal" data classes:

* N-dimensional classes:
    * Arrays: any extension of matrices with more than 2 dimensions, e.g. 3x3x3 cube
    * Lists: more flexible container for R objects. 


